# ğŸ§© Scribble Sync â€“ Architecture Documentation

This document provides an overview of the system design, data flow, and major architectural decisions for **Scribble Sync**, a real-time collaborative drawing and chat platform built with **Node.js**, **Express**, and **Socket.IO**.

---

## ğŸ§  Data Flow Diagram

   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   User A     â”‚
   â”‚ (Canvas + UI)â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ draw/chat event
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Socket.IO   â”‚
   â”‚   (client)   â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
    WebSocket message
          â”‚
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Node.js Server  â”‚
   â”‚ (Express + IO)   â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ broadcast event
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   User B     â”‚
   â”‚ (Canvas + UI)â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Each user emits events (drawing strokes, chat messages, undo/redo actions) via **Socket.IO**, which the server broadcasts to all other connected clients in real-time.

---

## ğŸ”Œ WebSocket Protocol

### **Message Types**

| Event Name | Direction | Payload | Description |
|-------------|------------|----------|-------------|
| `draw` | client â†’ server | `{ x, y, color, size, tool, userId }` | Sent while drawing |
| `strokeEnd` | client â†’ server | `{ strokeId }` | Marks completion of a stroke |
| `undo` | client â†’ server | `{ userId }` | Requests undo action |
| `redo` | client â†’ server | `{ userId }` | Requests redo action |
| `chatMessage` | client â†” server | `{ userId, message, timestamp }` | Chat message event |
| `cursorMove` | client â†’ server | `{ x, y, userId }` | Real-time cursor tracking |

The server uses **Socket.IOâ€™s broadcast** mechanism to emit these updates to all clients except the sender, ensuring consistent state across all connected canvases.

---

## ğŸ” Undo / Redo Strategy

Undo/redo are implemented **client-side** but triggered globally:

- Each stroke drawn is saved in a local `history` stack:
  ```js
  let history = [];
  let undone = [];
